///////////////////////////////////////////////////////////////
// Matrix uniforms for transformation and projection
uniform float4x4 matWorld;                  // World matrix: transforms object space to world space
uniform float4x4 matView;                   // View matrix: transforms world space to camera/view space
uniform float4x4 matProjection;             // Projection matrix: transforms view space to clip space
uniform float4x4 matWorldView;              // Combined world and view matrix
uniform float4x4 matWorldViewProjection;    // Combined world, view, and projection matrix
///////////////////////////////////////////////////////////////
// Texture sampler for the albedo (color) texture
uniform sampler2D smpAlbedo : register(s0); // Sampler for accessing the albedo texture, bound to register s0
///////////////////////////////////////////////////////////////
uniform float4 LightPosition;
///////////////////////////////////////////////////////////////
float3 convert_height_to_normal(float HeightMap)
{
    float DUHeightMap = ddx(HeightMap);
    float DVHeightMap = ddy(HeightMap);
    float3 HeightToNormal = normalize(cross(float3(1, 0.0f, DUHeightMap), float3(0.0f, 1, DVHeightMap)));
    return HeightToNormal;
}
///////////////////////////////////////////////////////////////
float3 sRgbToLinear(float3 vValue)
{
    return vValue * (vValue * (vValue * 0.305306011 + 0.682171111) + 0.012522878);
}

float3 LinearTosRgb(float3 vColor)
{
    float3 S1 = sqrt(vColor);
    float3 S2 = sqrt(S1);
    float3 S3 = sqrt(S2);
    return (0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3);
}
///////////////////////////////////////////////////////////////
// Input structure for vertex shader
struct VertexInput
{
    float3 Position : POSITION; // Vertex position in object space
    float3 Tangent : TANGENT;
    float3 Normal : NORMAL;     // Vertex normal vector in object space
    float2 UV : TEXCOORD0;      // Texture coordinates for sampling the texture
};

// Output structure for interpolated data sent to the pixel shader
struct Interpolators
{
    float4 HomogeniousPosition : POSITION; // Transformed position in homogeneous coordinates for rasterization
    float3 Position : TEXCOORD0;           // Position in view space for lighting calculations
    float3 TBN0 : TEXCOORD1;
    float3 TBN1 : TEXCOORD2;
    float3 TBN2 : TEXCOORD3;
    float2 UV : TEXCOORD4;                 // Texture coordinates passed to the pixel shader
};
///////////////////////////////////////////////////////////////
// Vertex shader main function
Interpolators VSMain(VertexInput Input)
{
    Interpolators Output; // Create an instance of the output structure

    // Transform the vertex position by the combined World, View, and Projection matrix
    Output.HomogeniousPosition = mul(float4(Input.Position, 1.0f), matWorldViewProjection);
    
    // Calculate the vertex position in view space
    Output.Position = mul(float4(Input.Position, 1.0f), matWorldView).xyz;

    float3 Binormal = cross(Input.Tangent, Input.Normal);

    float3x3 TBN = mul((float3x3)matWorldView, float3x3( Input.Tangent.x, Binormal.x, Input.Normal.x,
														 Input.Tangent.y, Binormal.y, Input.Normal.y,
														 Input.Tangent.z, Binormal.z, Input.Normal.z ));
    Output.TBN0 = TBN[0];
    Output.TBN1 = TBN[1];
    Output.TBN2 = TBN[2];

    // Pass through the UV coordinates directly
    Output.UV = Input.UV;
    Output.UV.y = -Input.UV.y;

    return Output; // Return the interpolated data for use in the pixel shader
}

// Pixel shader main function
float4 PSMain(Interpolators Input) : COLOR0
{
    // Sample the albedo texture using the UV coordinates provided from the vertex shader
    float4 Albedo = tex2D(smpAlbedo, Input.UV);

    // Apply gamma correction to the sampled color (assumed linear to sRGB conversion)
    Albedo.rgb = sRgbToLinear(Albedo.rgb);

    float HeingtMap = dot(Albedo.rgb, Albedo.rgb);

    float3 NormalMap = convert_height_to_normal(HeingtMap);

    float3x3 TBN = float3x3(Input.TBN0, Input.TBN1, Input.TBN2);

    float3 NormalFlat = mul(TBN, float3(0, 0, 1));
    NormalFlat = normalize(NormalFlat);

    float3 NormalByMap = mul(TBN, NormalMap);
    NormalByMap = normalize(NormalByMap);

    // Calculate the view direction vector by negating the normalized position vector in view space
    float3 ViewDirection = -normalize(Input.Position);

    float3 LightDirection = normalize(Input.Position - LightPosition.xyz);

    // Compute the dot product between the normal and view direction, giving the cosine of the angle between them
    float NdotLByMappedNormal = max(dot(NormalByMap, LightDirection), 0.0f);
    float NdotLByFlatNormal = max(dot(NormalFlat, LightDirection), 0.0f);

    // Calculate the final color based on the texture color and the NdotV value for basic diffuse lighting
    float4 FinalColor = Albedo * NdotLByMappedNormal * NdotLByFlatNormal;

    // Apply inverse gamma correction back to linear space for rendering
    FinalColor.rgb = LinearTosRgb(FinalColor.rgb);

    //FinalColor.rgb = Normal;

    return FinalColor; // Return the final color which will be used as the fragment's output color
}
///////////////////////////////////////////////////////////////
